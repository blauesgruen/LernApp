/**
 * Debug-Hilfsprogramm f√ºr die persistente Dateisystem-Speicherung
 * Dieses Skript bietet erweiterte Debugging-Funktionen f√ºr die IndexedDB-Speicherung von DirectoryHandles
 */

// Guard gegen mehrfaches Laden
if (typeof window.DEBUG_PERSISTENT_STORAGE_LOADED !== 'undefined') {
    console.warn('‚ö†Ô∏è Debug-Tools f√ºr persistente Speicherung wurden bereits geladen. Doppelte Initialisierung vermieden.');
} else {
    window.DEBUG_PERSISTENT_STORAGE_LOADED = true;

    // Konstanten f√ºr den Zugriff auf die IndexedDB-Datenbank
    const DEBUG_DB_NAME = 'LernAppDirectoryHandles';
    const DEBUG_STORE_NAME = 'lernapp-directory-handles';
    const DEBUG_HANDLE_KEY_PREFIX = 'dir-handle-'; // Prefix f√ºr benutzerspezifische Handles
    const DEBUG_OLD_KEY_NAME = 'main-directory-handle';

// Sofort Meldung ausgeben, dass Debugging-Tools geladen wurden
if (window.logger) {
    window.logger.info('üìÇ Dateisystem-Debug-Tools geladen');
    window.logger.info('Verf√ºgbare Befehle: debugPersistentStorage(), clearStoredDirectoryHandle(), showDebugCommands(), testFileAccess()');
} else {
    console.log('%cüìÇ Dateisystem-Debug-Tools geladen', 'color: blue; font-weight: bold; font-size: 14px');
    console.log('Verf√ºgbare Befehle: debugPersistentStorage(), clearStoredDirectoryHandle(), showDebugCommands(), testFileAccess()');
}

/**
 * Pr√ºft und zeigt den Status der persistenten Dateisystem-Speicherung
 * @returns {Promise<Object>} Ein Objekt mit Statusinformationen
 */
async function debugPersistentStorage() {
    const logFunc = window.logger ? window.logger.info.bind(window.logger) : console.log;
    const warnFunc = window.logger ? window.logger.warn.bind(window.logger) : console.warn;
    const errorFunc = window.logger ? window.logger.error.bind(window.logger) : console.error;
    
    logFunc('üìÇ Persistente Speicher-Diagnose gestartet');
    
    try {
        const status = {
            browserSupport: 'showDirectoryPicker' in window,
            persistenceStatus: {
                hasIndexedDB: 'indexedDB' in window,
                hasLocalStorage: 'localStorage' in window,
                hasDirectoryHandleFlag: localStorage.getItem('hasDirectoryHandle') === 'true',
                hasStoredDirectoryHandleFlag: localStorage.getItem('hasStoredDirectoryHandle') === 'true'
            },
            directoryHandleStatus: {
                globalHandleExists: !!window.directoryHandle,
                globalHandleName: window.directoryHandle ? window.directoryHandle.name : null
            },
            indexedDBStatus: {},
            localStorage: {}
        };
        
        // IndexedDB Status pr√ºfen
        if (status.persistenceStatus.hasIndexedDB) {
            try {
                logFunc('Pr√ºfe IndexedDB...');
                
                const db = await openDebugDatabase();
                const tx = db.transaction(DEBUG_STORE_NAME, 'readonly');
                const store = tx.objectStore(DEBUG_STORE_NAME);
                
                // Aktuellen Benutzernamen ermitteln
                const username = localStorage.getItem('username') || 'default';
                const userHandleKey = `${DEBUG_HANDLE_KEY_PREFIX}${username}`;
                
                // Zuerst nach dem benutzerspezifischen Schl√ºssel suchen
                const request = store.get(userHandleKey);
                
                await new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        if (request.result) {
                            status.indexedDBStatus.hasStoredHandle = true;
                            status.indexedDBStatus.handleName = request.result.name;
                            status.indexedDBStatus.handleKind = request.result.kind;
                            status.indexedDBStatus.key = userHandleKey;
                            resolve();
                        } else {
                            // Falls nicht gefunden, nach dem alten Schl√ºssel suchen
                            const oldRequest = store.get(DEBUG_OLD_KEY_NAME);
                            oldRequest.onsuccess = () => {
                                status.indexedDBStatus.hasStoredHandle = !!oldRequest.result;
                                status.indexedDBStatus.handleName = oldRequest.result ? oldRequest.result.name : null;
                                status.indexedDBStatus.handleKind = oldRequest.result ? oldRequest.result.kind : null;
                                status.indexedDBStatus.key = DEBUG_OLD_KEY_NAME;
                                resolve();
                            };
                            oldRequest.onerror = (event) => {
                                status.indexedDBStatus.error = event.target.error.message;
                                reject(event.target.error);
                            };
                        }
                    };
                    request.onerror = (event) => {
                        status.indexedDBStatus.error = event.target.error.message;
                        reject(event.target.error);
                    };
                    tx.oncomplete = () => {
                        db.close();
                    };
                });
                
                if (status.indexedDBStatus.hasStoredHandle) {
                    logFunc(`IndexedDB-Status: Handle gefunden ‚úì - Name: ${status.indexedDBStatus.handleName}, Typ: ${status.indexedDBStatus.handleKind}`);
                } else {
                    warnFunc('IndexedDB-Status: Kein Handle gefunden ‚úó');
                }
            } catch (error) {
                status.indexedDBStatus.error = error.message;
                errorFunc(`‚ùå Fehler beim Zugriff auf IndexedDB: ${error.message}`);
            }
        } else {
            warnFunc('‚ö†Ô∏è IndexedDB wird nicht unterst√ºtzt');
        }
        
        // localStorage pr√ºfen
        if (status.persistenceStatus.hasLocalStorage) {
            logFunc('Pr√ºfe localStorage...');
            const username = localStorage.getItem('username');
            status.localStorage = {
                username,
                storagePath: localStorage.getItem('storagePath') || localStorage.getItem(`storagePath_${username}`),
                hasDirectoryHandle: localStorage.getItem(`hasDirectoryHandle_${username}`) === 'true',
                hasStoredDirectoryHandle: localStorage.getItem(`hasStoredDirectoryHandle_${username}`) === 'true'
            };
            
            logFunc(`Benutzer: ${status.localStorage.username || 'Nicht eingeloggt'}`);
            logFunc(`Speicherpfad: ${status.localStorage.storagePath || 'Nicht konfiguriert'}`);
            logFunc(`DirectoryHandle-Flag: ${status.localStorage.hasDirectoryHandle ? 'Gesetzt ‚úì' : 'Nicht gesetzt ‚úó'}`);
            logFunc(`StoredDirectoryHandle-Flag: ${status.localStorage.hasStoredDirectoryHandle ? 'Gesetzt ‚úì' : 'Nicht gesetzt ‚úó'}`);
        } else {
            warnFunc('‚ö†Ô∏è localStorage wird nicht unterst√ºtzt');
        }
        
        // Globales DirectoryHandle pr√ºfen
        logFunc('Pr√ºfe globales DirectoryHandle...');
        if (status.directoryHandleStatus.globalHandleExists) {
            logFunc(`‚úì Globales DirectoryHandle vorhanden - Name: ${status.directoryHandleStatus.globalHandleName}`);
            
            // Berechtigungsstatus pr√ºfen
            try {
                if (window.verifyPermission) {
                    const permission = await window.verifyPermission(window.directoryHandle);
                    status.directoryHandleStatus.permission = permission;
                    logFunc(`Berechtigungsstatus: ${permission}`);
                } else {
                    warnFunc('‚ö†Ô∏è verifyPermission-Funktion nicht gefunden');
                    
                    // Fallback: Direkte Berechtigungspr√ºfung
                    const permission = await window.directoryHandle.requestPermission({ mode: 'readwrite' });
                    status.directoryHandleStatus.permission = permission;
                    logFunc(`Berechtigungsstatus (direkt): ${permission}`);
                }
            } catch (error) {
                status.directoryHandleStatus.permissionError = error.message;
                errorFunc(`‚ùå Fehler bei der Berechtigungspr√ºfung: ${error.message}`);
            }
        } else {
            warnFunc('‚úó Kein globales DirectoryHandle vorhanden');
        }
        
        logFunc('üìä Zusammenfassung');
        const summaryStatus = getSummaryStatus(status);
        logFunc(`Gesamtstatus: ${summaryStatus.text}`);
        logFunc(`Empfehlung: ${summaryStatus.recommendation}`);
        
        return status;
    } catch (error) {
        errorFunc(`Fehler bei der Diagnose: ${error.message}`);
        return { error: error.message };
    }
}

/**
 * √ñffnet die Debug-Datenbank
 * @returns {Promise<IDBDatabase>} Die ge√∂ffnete Datenbank
 */
function openDebugDatabase() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DEBUG_DB_NAME, 3);  // Version auf 3 aktualisiert
        
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(DEBUG_STORE_NAME)) {
                db.createObjectStore(DEBUG_STORE_NAME);
            }
        };
        
        request.onsuccess = (event) => {
            resolve(event.target.result);
        };
        
        request.onerror = (event) => {
            reject(event.target.error);
        };
    });
}

/**
 * Erstellt eine Zusammenfassung des Systemstatus
 * @param {Object} status Das Status-Objekt
 * @returns {Object} Ein Objekt mit Zusammenfassung und Empfehlung
 */
function getSummaryStatus(status) {
    // Haben wir ein funktionierendes DirectoryHandle?
    const hasWorkingHandle = status.directoryHandleStatus.globalHandleExists && 
                             status.directoryHandleStatus.permission === 'granted';
    
    // Ist ein Handle in IndexedDB gespeichert?
    const hasStoredHandle = status.indexedDBStatus.hasStoredHandle;
    
    // Gibt es Flags in localStorage, die auf ein Handle hindeuten?
    const hasHandleFlags = status.localStorage.hasDirectoryHandle || 
                          status.localStorage.hasStoredDirectoryHandle;
    
    if (hasWorkingHandle) {
        return {
            text: 'Funktionsf√§hig ‚úì',
            recommendation: 'Das System funktioniert korrekt, keine Aktion erforderlich.'
        };
    } else if (hasStoredHandle && !hasWorkingHandle) {
        return {
            text: 'Wiederherstellbar ‚ö†Ô∏è',
            recommendation: 'Ein Handle ist gespeichert, konnte aber nicht wiederhergestellt werden. ' +
                           'F√ºhren Sie window.restoreDirectoryHandle() aus oder w√§hlen Sie einen ' +
                           'Speicherort neu aus.'
        };
    } else if (hasHandleFlags && !hasStoredHandle) {
        return {
            text: 'Inkonsistent ‚ö†Ô∏è',
            recommendation: 'Flags deuten auf ein Handle hin, aber keines ist gespeichert. ' +
                           'Setzen Sie einen neuen Speicherort mit window.openAndPersistDirectoryPicker().'
        };
    } else {
        return {
            text: 'Nicht konfiguriert ‚ÑπÔ∏è',
            recommendation: 'Kein Speicherort konfiguriert. W√§hlen Sie einen Speicherort mit ' +
                           'window.openAndPersistDirectoryPicker() aus.'
        };
    }
}

/**
 * Versucht, ein gespeichertes DirectoryHandle aus IndexedDB zu l√∂schen
 * @returns {Promise<boolean>} True, wenn das Handle erfolgreich gel√∂scht wurde
 */
async function clearStoredDirectoryHandle() {
    const logFunc = window.logger ? window.logger.info.bind(window.logger) : console.log;
    const errorFunc = window.logger ? window.logger.error.bind(window.logger) : console.error;
    
    try {
        logFunc('Versuche, gespeichertes DirectoryHandle zu l√∂schen...');
        
        const db = await openDebugDatabase();
        const tx = db.transaction(DEBUG_STORE_NAME, 'readwrite');
        const store = tx.objectStore(DEBUG_STORE_NAME);
        
        // Aktuellen Benutzernamen ermitteln
        const username = localStorage.getItem('username') || 'default';
        const userHandleKey = `${DEBUG_HANDLE_KEY_PREFIX}${username}`;
        
        await new Promise((resolve, reject) => {
            // Zuerst den benutzerspezifischen Schl√ºssel l√∂schen
            const userRequest = store.delete(userHandleKey);
            
            userRequest.onsuccess = () => {
                logFunc(`‚úì Benutzerspezifisches DirectoryHandle (${userHandleKey}) gel√∂scht`);
                
                // Dann den alten Schl√ºssel l√∂schen
                const oldRequest = store.delete(DEBUG_OLD_KEY_NAME);
                
                oldRequest.onsuccess = () => {
                    logFunc(`‚úì Altes DirectoryHandle (${DEBUG_OLD_KEY_NAME}) gel√∂scht`);
                    resolve();
                };
                
                oldRequest.onerror = (event) => {
                    logFunc(`Altes DirectoryHandle nicht gefunden oder konnte nicht gel√∂scht werden: ${event.target.error.message}`);
                    resolve(); // Trotzdem fortfahren
                };
            };
            
            userRequest.onerror = (event) => {
                logFunc(`Benutzerspezifisches DirectoryHandle nicht gefunden oder konnte nicht gel√∂scht werden: ${event.target.error.message}`);
                
                // Versuchen, das alte zu l√∂schen
                const oldRequest = store.delete(DEBUG_OLD_KEY_NAME);
                
                oldRequest.onsuccess = () => {
                    logFunc(`‚úì Altes DirectoryHandle (${DEBUG_OLD_KEY_NAME}) gel√∂scht`);
                    resolve();
                };
                
                oldRequest.onerror = (event) => {
                    errorFunc(`Fehler beim L√∂schen des alten DirectoryHandle: ${event.target.error.message}`);
                    reject(event.target.error);
                };
            };
            
            tx.oncomplete = () => {
                db.close();
            };
        });
        
        // Benutzerspezifische Flags in localStorage zur√ºcksetzen
        localStorage.removeItem(`hasDirectoryHandle_${username}`);
        localStorage.removeItem(`hasStoredDirectoryHandle_${username}`);
        localStorage.removeItem(`directoryHandleName_${username}`);
        localStorage.removeItem(`directoryHandleName_${username}`);
        
        // F√ºr Abw√§rtskompatibilit√§t auch die alten Flags zur√ºcksetzen
        localStorage.removeItem('hasDirectoryHandle');
        localStorage.removeItem('hasStoredDirectoryHandle');
        localStorage.removeItem('directoryHandleName');
        
        logFunc('Flags in localStorage zur√ºckgesetzt');
        
        return true;
    } catch (error) {
        errorFunc(`Fehler beim L√∂schen des gespeicherten DirectoryHandle: ${error.message}`);
        return false;
    }
}

/**
 * Zeigt die verf√ºgbaren Debug-Kommandos an
 */
function showDebugCommands() {
    const logFunc = window.logger ? window.logger.info.bind(window.logger) : console.log;
    
    logFunc('üõ†Ô∏è Verf√ºgbare Debug-Kommandos:');
    logFunc('- debugPersistentStorage(): F√ºhrt eine vollst√§ndige Diagnose des Dateisystem-Zugriffs durch');
    logFunc('- clearStoredDirectoryHandle(): L√∂scht das gespeicherte DirectoryHandle (f√ºr einen Neustart)');
    logFunc('- window.openAndPersistDirectoryPicker(): √ñffnet den Dateibrowser und speichert das ausgew√§hlte Handle');
    logFunc('- window.restoreDirectoryHandle(): Versucht, ein gespeichertes DirectoryHandle wiederherzustellen');
    logFunc('- window.forceRestoreDirectoryHandle(): Erweiterte Wiederherstellung des gespeicherten DirectoryHandle');
    logFunc('- testFileAccess(): Testet den Dateisystem-Zugriff durch Schreiben einer Testdatei');
}

// Debug-Kommandos anzeigen
showDebugCommands();

/**
 * Manueller Test des Dateisystem-Zugriffs
 */
async function testFileAccess() {
    const logFunc = window.logger ? window.logger.info.bind(window.logger) : console.log;
    const errorFunc = window.logger ? window.logger.error.bind(window.logger) : console.error;
    
    if (!window.directoryHandle) {
        errorFunc('Kein DirectoryHandle vorhanden. Bitte w√§hlen Sie einen Speicherort aus.');
        return false;
    }
    
    try {
        logFunc('Teste Schreibzugriff auf das Dateisystem...');
        
        // Testdatei erstellen
        const fileHandle = await window.directoryHandle.getFileHandle('lernapp_debug_test.txt', { create: true });
        const writable = await fileHandle.createWritable();
        
        // Testdaten
        const testData = `LernApp Debug-Test: ${new Date().toISOString()}\n` +
                         `Zufallszahl: ${Math.random()}\n`;
        
        await writable.write(testData);
        await writable.close();
        
        logFunc(`‚úì Testdatei erfolgreich geschrieben: lernapp_debug_test.txt`);
        logFunc(`Inhalt: ${testData}`);
        
        // Datei lesen
        const file = await fileHandle.getFile();
        const content = await file.text();
        
        logFunc(`‚úì Testdatei erfolgreich gelesen: ${content.substring(0, 50)}...`);
        
        // Verf√ºgbare Dateien auflisten
        logFunc('Dateien im Verzeichnis:');
        const entries = [];
        for await (const entry of window.directoryHandle.values()) {
            entries.push(`${entry.name} (${entry.kind})`);
            if (entries.length >= 5) break; // Maximal 5 Eintr√§ge
        }
        
        logFunc(`Gefundene Dateien (max. 5): ${entries.join(', ')}`);
        
        return true;
    } catch (error) {
        errorFunc(`Fehler beim Testen des Dateisystem-Zugriffs: ${error.message}`);
        return false;
    }
}

/**
 * Versucht mit zus√§tzlichen Methoden, ein gespeichertes DirectoryHandle aus IndexedDB wiederherzustellen
 * @returns {Promise<Object|null>} Das wiederhergestellte DirectoryHandle oder null
 */
async function forceRestoreDirectoryHandle() {
    const logFunc = window.logger ? window.logger.info.bind(window.logger) : console.log;
    const warnFunc = window.logger ? window.logger.warn.bind(window.logger) : console.warn;
    const errorFunc = window.logger ? window.logger.error.bind(window.logger) : console.error;
    
    logFunc('Versuche, DirectoryHandle wiederherzustellen (erweiterte Methode)...');
    
    // Zuerst √ºber die normale Methode versuchen, falls sie existiert
    if (window.restoreDirectoryHandle) {
        try {
            logFunc('Versuche, DirectoryHandle √ºber normale Methode wiederherzustellen...');
            const result = await window.restoreDirectoryHandle();
            if (result === true) {
                logFunc('‚úì DirectoryHandle √ºber normale Methode wiederhergestellt');
                return window.directoryHandle;
            } else if (window.directoryHandle) {
                logFunc('‚úì DirectoryHandle nach Aufruf von restoreDirectoryHandle verf√ºgbar');
                return window.directoryHandle;
            }
        } catch (error) {
            warnFunc(`Normale Wiederherstellungsmethode fehlgeschlagen: ${error.message}`);
        }
    }
    
    // Direkter Zugriff auf IndexedDB
    try {
        logFunc('Versuche, DirectoryHandle direkt aus IndexedDB zu laden...');
        
        const db = await openDebugDatabase();
        const tx = db.transaction(DEBUG_STORE_NAME, 'readonly');
        const store = tx.objectStore(DEBUG_STORE_NAME);
        
        const handle = await new Promise((resolve, reject) => {
            const request = store.get(DEBUG_KEY_NAME);
            
            request.onsuccess = () => {
                if (request.result) {
                    logFunc('‚úì DirectoryHandle in IndexedDB gefunden');
                    resolve(request.result);
                } else {
                    warnFunc('‚úó Kein DirectoryHandle in IndexedDB gefunden');
                    resolve(null);
                }
            };
            
            request.onerror = (event) => {
                errorFunc(`Fehler beim Laden des DirectoryHandle: ${event.target.error.message}`);
                reject(event.target.error);
            };
            
            tx.oncomplete = () => {
                db.close();
            };
        });
        
        if (handle) {
            // Versuchen, Berechtigung zu erhalten
            try {
                logFunc('Pr√ºfe Berechtigung f√ºr wiederhergestellten Handle...');
                
                // Teste verschiedene Arten, die Berechtigungen zu pr√ºfen und anzufordern
                let permission;
                
                // Zuerst die Standard-Methode
                try {
                    permission = await handle.requestPermission({ mode: 'readwrite' });
                    logFunc(`Berechtigungsstatus: ${permission}`);
                } catch (permError1) {
                    warnFunc(`Fehler bei Standard-Berechtigungspr√ºfung: ${permError1.message}`);
                    
                    // Fallback 1: Versuchen, queryPermission zu verwenden
                    try {
                        permission = await handle.queryPermission({ mode: 'readwrite' });
                        logFunc(`Berechtigung durch queryPermission: ${permission}`);
                        
                        // Wenn wir noch keine Berechtigung haben, versuchen wir es erneut anzufordern
                        if (permission !== 'granted') {
                            try {
                                permission = await handle.requestPermission({ mode: 'readwrite' });
                                logFunc(`Berechtigung nach queryPermission erneut angefordert: ${permission}`);
                            } catch (permError2) {
                                warnFunc(`Fehler bei erneuter Berechtigungsanfrage: ${permError2.message}`);
                            }
                        }
                    } catch (permError3) {
                        warnFunc(`Fehler bei queryPermission: ${permError3.message}`);
                    }
                }
                
                if (permission === 'granted') {
                    logFunc('‚úì Berechtigung f√ºr wiederhergestellten Handle erhalten');
                    // Globales Handle aktualisieren
                    window.directoryHandle = handle;
                    
                    // Flags in localStorage aktualisieren
                    localStorage.setItem('hasDirectoryHandle', 'true');
                    localStorage.setItem('hasStoredDirectoryHandle', 'true');
                    
                    // Testen, ob der Zugriff tats√§chlich funktioniert
                    try {
                        if (window.testFileAccess) {
                            const testResult = await window.testFileAccess();
                            logFunc(`Dateisystem-Zugriffstest: ${testResult ? 'Erfolgreich' : 'Fehlgeschlagen'}`);
                        }
                    } catch (testError) {
                        warnFunc(`Warnung beim Testen des Dateisystemzugriffs: ${testError.message}`);
                    }
                    
                    return handle;
                } else {
                    warnFunc(`‚úó Keine Berechtigung f√ºr wiederhergestellten Handle: ${permission}`);
                    
                    // Trotzdem das Handle zur√ºckgeben, da der Benutzer sp√§ter die Berechtigung erteilen kann
                    logFunc('Handle wird zur√ºckgegeben, auch ohne Berechtigung');
                    window.directoryHandle = handle;
                    return handle;
                }
            } catch (permError) {
                errorFunc(`Fehler bei der Berechtigungspr√ºfung: ${permError.message}`);
                
                // Trotzdem das Handle zur√ºckgeben, da wir es sp√§ter noch einmal versuchen k√∂nnen
                logFunc('Handle wird trotz Fehler zur√ºckgegeben');
                window.directoryHandle = handle;
                return handle;
            }
        }
        
        return null;
    } catch (error) {
        errorFunc(`Fehler beim direkten Laden des DirectoryHandle: ${error.message}`);
        return null;
    }
}

// Exportiere die Funktionen im globalen Namespace
window.debugPersistentStorage = debugPersistentStorage;
window.clearStoredDirectoryHandle = clearStoredDirectoryHandle;
window.showDebugCommands = showDebugCommands;
window.testFileAccess = testFileAccess;
window.forceRestoreDirectoryHandle = forceRestoreDirectoryHandle;

} // Ende des Guards gegen mehrfaches Laden
